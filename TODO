
* Assignments to "complex" l-values -- subscript, getitem, and maybe function calls
    * Including how to deal with dependencies on (parts of) compound objects
* Loops: For, While
* Returning from within a loop
* Internal call arguments that are not part of the optimizee - let them pass through.
* Allow additional outgoing edges from nodes_to_replace that are mere aliases of inputs to the optimized graph
* Finding a place for the preface when some code (which will be removed) comes between needed assigns e.g.

    tmp1 = np.dot(j,k)
    m = rng.uniform(size=(c,d))
    y = np.dot(tmp1,m)

* Get rid of redundant arguments created by prepare_statement_with_internal_calls
* Branching: If, Try/Except
* multiple assign
* multiple statements on a line
* Comprehensions
* Combine adjacent guards



DONE: 
* Multiple visits to same code line
* Memory leaks -- (not done, but determined it's an astroid problem)
* Fix "fanout" for args that pass through an intfunccall (done - no more IntFuncCallNodes)
* Fix "stranded" nodes in dfg






-----------


* Assignments to "complex" l-values -- subscript, getitem, and maybe function calls

Probably I will only deal with l-values that are "atomic" - i.e. no function calls or custom __getitem__/__getattr__
To be careful, I should check that the "thing" I am changing is what I think it is
